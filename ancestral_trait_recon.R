
# Load libraries
#biocLite libraries
#source("https://bioconductor.org/biocLite.R")
# biocLite("BiocUpgrade")
#biocLite()
	library(ggtree)

#devtools
# library( devtools )
	library(hutan)
# install_github( 'caseywdunn/hutan' )
	library("agalmar")
#install_github( 'caseywdunn/agalmar')

#CRAN libraries
#	library(gridExtra)
  library(ggplot2)
	library(knitr)
  library(ape)
	library(picante)
	library(tidyverse)
  library(GGally)
  library(digest)
  library(magrittr)
  library(Rphylopars)
  library( phytools )
	library( parallel )

  #this is a biocLite library
  library(treeio)

  	## The minimum number of counts to pass gene sampling criteria
	min_count <- 1

	## p value cutoff for evaluating differential expression significance
	p_value_threshold <- 0.05

	focal_species <- c( "Agalma elegans", "Nanomia bijuga", "Bargmannia elongata", "Frillagalma vityazi", "Diphyes dispar", "Physalia physalis", "Apolemia lanosa" )

## Gene tree parameters

	### The default branch length pace holder used in the gene tree inference software

		default_length_val <- 1e-06 # Based on Phyldog

	### Exclude trees with branches that exceed length threshold
	edge_length_max_threshold <- 2

	### Exclude trees that exceed specified fraction of branches with default values
	fraction_default_max_threshold <- 0.25

	### The minimum number of tips with expression data for a tree to be considered
	min_tips <- 3

	### The maximum root depth of gene trees, where the root of the species tree is 1
	### Gene trees that exceed this threshold are removed
	max_root_depth <- 5
	
	###number of speciation nodes that don't match topology of species tree that can be tolerated
	max_x_per_node<-0.3

	# Set system computational parameters
	cores <- detectCores() - 1
	if ( cores < 1 ) {
		cores <- 1
	}
	set.seed( 23456 )

	# Configure knitr, see http://yihui.name/knitr/options
	opts_knit$set( progress = TRUE, verbose = TRUE )

	cores <- detectCores() - 1

#generated by Manuscript_prep.R
	load("Manuscript_prep.RData")

rm(i)

source( "functions.R" )

#generate pruned trees for each of the focal column values

	focal_pic_values<-c("log2FoldChange_GasdevPalmat","log2FoldChange_GasdevGasmat","log2FoldChange_GasdevNecdev","log2FoldChange_GasdevPne","log2FoldChange_GasdevBradev","log2FoldChange_GasdevGonmal","log2FoldChange_GasdevGonfem","log2FoldChange_PalmatGasmat","log2FoldChange_PalmatNecdev","log2FoldChange_PalmatPne","log2FoldChange_PalmatBradev","log2FoldChange_PalmatGonmal","log2FoldChange_PalmatGonfem","log2FoldChange_GasmatNecdev","log2FoldChange_GasmatPne","log2FoldChange_GasmatBradev","log2FoldChange_GasmatGonmal","log2FoldChange_GasmatGonfem","log2FoldChange_NecdevPne","log2FoldChange_NecdevBradev","log2FoldChange_NecdevGonmal","log2FoldChange_NecdevGonfem","log2FoldChange_PneBradev","log2FoldChange_PneGonmal","log2FoldChange_PneGonfem","log2FoldChange_BradevGonmal","log2FoldChange_BradevGonfem","log2FoldChange_GonmalGonfem","Gasdev","Palmat","Gasmat","Necdev","Pne","Bradev","Gonmal","Gonfem")

  focal_tpm_values<-c("Gasdev","Palmat","Gasmat","Necdev","Pne","Bradev","Gonmal","Gonfem")

#Create subtrees with only tips that have expression data for each of the column values
	gene_trees_pruned <- parallel::mclapply(gene_trees_calibrated,drop_empty_tips,col_values=focal_pic_values, mc.cores=cores)

	#add ancestral trait values

	acetreat<-function(nhx,col_value){
  m<-list()
  for(i in 1:length(col_value)){
  m[[i]]<-ace_trees(nhx,col_value[i])
  }
  return(m)
	}
	
	

	#generate a list of digests for each of these trees so that they can go back into the main calibrated gene trees
	digests <- unlist( lapply(gene_trees_pruned, digest ) )

  trees_digest<-gene_trees_pruned

  names(trees_digest)<-digests

#add ancestral reconstructions of tpm values to the trees
  gene_trees_ace<-acetreat(trees_digest,focal_tpm_values)
  
#function to merge the subtrees with the tree digest
  merge_ace_pruned<-function(ace_tree,treedigest){
    m<-list()
	for(i in 1:length(digests)){
	  if(is.null(ace_tree[digests[i]][[1]])){
	    m[[i]]<- treedigest[digests[i]][[1]]
	  }
	  else{
	    m[[i]]<-merge_ace(ace_tree[digests[i]][[1]],treedigest[digests[i]][[1]])
	  }
	}
    return(m)
  }

  #merge the subtrees with the tree digest
  l<-list()
  for(i in 1:length(gene_trees_ace)){
	l[[i]]<- merge_ace_pruned(ace_tree=gene_trees_ace[[i]],treedigest=trees_digest)
  }

  #merge the ace trees back into the calibrated gene trees
  gene_trees_ace_calibrated <- mapply( merge_ace, l[[1]], gene_trees_calibrated )
  for(i in 2:length(l)){
  gene_trees_ace_calibrated <- mapply( merge_ace, l[[i]], gene_trees_ace_calibrated )
  }

  rm(l)
  rm(gene_trees_ace)

  #add the ace values into the same column
  gene_trees_ace_calibrated<-lapply(gene_trees_ace_calibrated, function(nhx){
       if ( class( nhx ) != "treedata" ) {
      return( NA )
       }
    for(i in 1:length(focal_tpm_values)){
      if(paste("ace",focal_tpm_values[[i]],sep="_") %in% names(nhx@data)){
      nhx@data[,names(nhx@data)==focal_tpm_values[[i]]][which(!is.na(nhx@data[,paste("ace",focal_tpm_values[[i]],sep="_")])),]<-nhx@data[,paste("ace",focal_tpm_values[[i]],sep="_")][which(!is.na(nhx@data[,paste("ace",focal_tpm_values[[i]],sep="_")])),]
      }
  }
  return(nhx)
  }
  )

#add tau values to calibrated trees
  gene_trees_ace_calibrated<-lapply(gene_trees_ace_calibrated,tau)

  #prune the calibrated tips to consider only the focal tpm values
  gene_trees_ace_calibrated_pruned<-parallel::mclapply(gene_trees_ace_calibrated,drop_empty_tips,col_values=focal_tpm_values, mc.cores=cores)

#create an object with all of the edge data
  edges_ace <-
    parallel::mclapply(
			gene_trees_ace_calibrated_pruned,
			summarize_ace_edges,
			default_length_val=default_length_val,
			mc.cores=cores
		) %>%
		bind_rows()

  #and all of the node data
  nodes_ace <-
    parallel::mclapply(
	  	gene_trees_ace_calibrated_pruned,
	  	summarize_nodes.mod,
	  	default_length_val = default_length_val,
	  	mc.cores=cores
	  ) %>%
	  bind_rows()

  #these are all of the digests that correspond to the digests in the edges_ace and nodes_ace objects
  gene_trees_ace_digests<-unlist(lapply(gene_trees_ace_calibrated_pruned, digest))

  rm(i)



#generate brownian motion parameters

 trees_digest<-gene_trees_pruned

  names(trees_digest)<-digests

  paramtreat<-function(nhx,col_values){
  m<-list()
  for(i in 1:length(col_values)){
  m[[i]]<-add_model_parameters_trees(nhx,col_values[i])
  }
  return(m)
  }

sim_trees<-paramtreat(trees_digest,focal_tpm_values)

 merge_sim_pruned<-function(simtrees,treedigest){
    m<-list()
	for(i in 1:length(digests)){
	  if(is.null(simtrees[digests[i]][[1]])){
	    m[[i]]<- treedigest[digests[i]][[1]]
	  }
	  else{
	    m[[i]]<-merge_sim(simtrees[digests[i]][[1]],treedigest[digests[i]][[1]])
	  }
	}
    return(m)
 }

#strip away all of the original sequence data from trees_digest
 strip_treedata <- function(nhx){

   if ( class( nhx )!="treedata" ) {
    return( NA )
  }
  nhx@data<-nhx@data[,names(nhx@data) %in% c("Ev","S","ND","node","phy_node_names","species","sequence_ids","node_depth","blast_hit","node_age","node.label_original")]
 return(nhx)
 }


  trees_digest<-lapply(trees_digest,strip_treedata)

	#merge the subtrees with the tree digest
  l<-list()
  for(i in 1:length(sim_trees)){
	l[[i]]<- merge_sim_pruned(sim_trees[[i]],trees_digest)
  }

  gene_trees_calibrated2<-gene_trees_calibrated
  gene_trees_calibrated2<-lapply(gene_trees_calibrated2,strip_treedata)

  #put the data back into the calibrated trees
  gene_trees_sim_calibrated <- mapply( merge_sim, l[[1]], gene_trees_calibrated2 )
  for(i in 2:length(l)){
  gene_trees_sim_calibrated <- mapply( merge_sim, l[[i]], gene_trees_sim_calibrated )
  }

  rm(l)

  rm(gene_trees_calibrated2)

#add the ace values into the same column
gene_trees_sim_calibrated<-lapply(gene_trees_sim_calibrated, function(nhx){
  if ( class( nhx ) != "treedata" ) {
      return( NA )
       }
    for(i in 1:length(focal_tpm_values)){
      if(paste("ace",focal_tpm_values[[i]],sep="_") %in% names(nhx@data)){
      nhx@data[,names(nhx@data)==focal_tpm_values[[i]]][which(!is.na(nhx@data[,paste("ace",focal_tpm_values[[i]],sep="_")])),]<-nhx@data[,paste("ace",focal_tpm_values[[i]],sep="_")][which(!is.na(nhx@data[,paste("ace",focal_tpm_values[[i]],sep="_")])),]
      }
  }
  return(nhx)
  }
  )

#remove trees that failed fastContinuous
  gene_trees_sim_calibrated<-lapply(gene_trees_sim_calibrated,function(nhx,col_values){
    if ( class( nhx ) != "treedata" ) {
      return( NA )
       }
    if(any(names(nhx@data[is.tip.nhx( nhx ), ]) %in% col_values)==FALSE){
      return( NA )  }

#Add NA columns where there is missing data for particular col_values
    if(any((col_values %in% names(nhx@data[is.tip.nhx( nhx ), ]))==FALSE)){
      if(length(length(which(!col_values %in% names(nhx@data)))==1)){
        nhx@data[,col_values[which(!col_values %in% names(nhx@data))]]<-rep(NA,nrow(nhx@data))
        return(nhx)
      }
      else{
       missing_values<-col_values[which(!col_values %in% names(nhx@data))]
       for(i in 1:length(missing_values)){
         nhx@data[,missing_values[i]]<-rep(NA,nrow(nhx@data))
       }
       return(nhx)
      }
    }

    else{
      return(nhx)
    }
    },focal_tpm_values)


#add tau values to calibrated trees
  gene_trees_sim_calibrated<-lapply(gene_trees_sim_calibrated,tau)

#prune the calibrated tips to consider only the focal fpkm values
  gene_trees_sim_calibrated_pruned<-lapply(gene_trees_sim_calibrated,drop_empty_tips,col_values=focal_tpm_values)
  
  


##identifying why certain trees failed fitCont analyses

  #sim_na<-which(is.na(gene_trees_sim_calibrated_pruned))

  #ace_na<-which(is.na(gene_trees_ace_calibrated_pruned))

#list of gene trees
  #x<-sim_na[which(!(sim_na %in% ace_na))]

  #failed_trees<-gene_trees_ace_calibrated_pruned[x]

#create an object with all of the edge data
  edges_sim <-
		parallel::mclapply(
			gene_trees_sim_calibrated_pruned,
			summarize_ace_edges,
			default_length_val=default_length_val,
			mc.cores=cores
		) %>%
		bind_rows()

#add all of the node data
  nodes_sim <-
	  parallel::mclapply(
	  	gene_trees_sim_calibrated_pruned,
	  	summarize_nodes.mod,
	  	default_length_val = default_length_val,
	  	mc.cores=cores
	  ) %>%
	  bind_rows()

save.image(file="manuscript_checkpoint_ace.RData")
